# Generated BridgeJS Files

The files in this directory are auto-generated by the `bridge-js` plugin from JavaScriptKit. They provide the Swift bridge functions referenced by `@JSClass`, `@JSFunction`, `@JSGetter`, `@JSSetter`, and `@JS` macros in `Sources/WebGPU/Wasm/`.

## When to regenerate

Run the plugin whenever you change the `@JSClass`/`@JS`-annotated declarations in `Sources/WebGPU/Wasm/`:

- Adding a new `@JSClass` struct or `@JS` struct/enum
- Adding, removing, or changing `@JSGetter`, `@JSSetter`, or `@JSFunction` members
- Changing parameter types or return types on bridged functions

You do **not** need to re-run it if you're only changing non-bridged code.

## Command

```sh
swift package plugin --allow-writing-to-package-directory bridge-js
```

## Generated files

- `BridgeJS.swift` — Swift bridge functions with `@_extern(wasm, ...)` imports and protocol conformances
- `JavaScript/BridgeJS.json` — JSON description used by the JS-side glue code at runtime

## Why these files are committed

The `bridge-js` plugin is a development-time tool, not a build-time plugin. It does not run automatically during `swift build`. If the generated files aren't checked in, anyone cloning the repo would need to run the plugin manually before they could build the `WebGPUWasm` target.

## Non-throwing wrapper pattern

The `@JSFunction`, `@JSGetter`, and `@JSSetter` macros generate methods that `throws(JSException)`, but the native Dawn backend exposes non-throwing APIs. To keep a unified public API across both platforms, every bridged declaration is **internal** and wrapped by a **public** non-throwing method that calls it with `try!`.

### Naming convention

Internal (throwing) declarations use a **leading underscore** to distinguish them from their public wrappers:

```swift
// Internal — generated by @JSFunction, throws
@JSFunction(jsName: "createBuffer")
func _createBuffer(_ descriptor: GPUBufferDescriptor) throws(JSException) -> GPUBuffer

// Public — non-throwing, matches Dawn's API
public func createBuffer(descriptor: GPUBufferDescriptor) -> GPUBuffer {
    try! _createBuffer(descriptor)
}
```

The same pattern applies to getters:

```swift
@JSGetter(jsName: "queue") var _queue: GPUQueue

public var queue: GPUQueue { try! _queue }
```

### Setter exception

The `@JSSetter` macro enforces that the Swift function name starts with `set` followed by the property name (e.g., `setLabel`). A leading underscore like `_setLabel` is rejected by the macro. As a workaround, setters use a **trailing underscore** instead:

```swift
@JSSetter(jsName: "label") func setLabel_(_ value: String?) throws(JSException)

public func setLabel(_ value: String?) {
    try! setLabel_(value)
}
```
